## 排序

* [选择排序](SelectionSort.java)   O(N^2)

* [冒泡排序](BubbleSort.java)      O(N^2)

* [插入排序](InsertionSort.java)   O(N^2)

* [归并排序(自顶向下)](MergeSort.java) O(N*lgN)

* [归并排序(自低向上)](MergeSort2.java) O(N*lgN)

* 归并排序的时间复杂度好的本质:没有浪费比较,每一轮比较结果保留下来，进入下一轮(选择、冒泡和插入每次比较是独立的)